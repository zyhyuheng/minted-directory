[{"data":1,"prerenderedAt":391},["ShallowReactive",2],{"featured-listing":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":7,"cover":9,"featured":10,"tags":11,"body":13,"_type":384,"_id":385,"_source":386,"_file":387,"_stem":388,"_extension":389,"sitemap":390},"/dir/java","dir",false,"","java流模式查询","/logo.png",true,[12],"SAAS",{"type":14,"children":15,"toc":382},"root",[16,23,29,35,41,51,64,73,82,91,100,105,111,119,128,136,145,150,155,161,172,181,186,196,205,210,220,229,234,244,253,258,263,269,274,283,288,297,308,313,322,327,337,342,351,356,362,367,372,377],{"type":17,"tag":18,"props":19,"children":20},"element","h1",{"id":8},[21],{"type":22,"value":8},"text",{"type":17,"tag":18,"props":24,"children":26},{"id":25},"一流式查询模式简介",[27],{"type":22,"value":28},"一、流式查询模式简介",{"type":17,"tag":30,"props":31,"children":32},"p",{},[33],{"type":22,"value":34},"流式查询模式是一种优化查询的方法，可以在查询大量数据时降低内存占用，提高查询速度。在流式查询模式下，查询结果是逐条从数据库服务器流式传输到客户端，而不是一次性将所有查询结果加载到内存中。",{"type":17,"tag":18,"props":36,"children":38},{"id":37},"二jdbc流式查询模式",[39],{"type":22,"value":40},"二、JDBC流式查询模式",{"type":17,"tag":42,"props":43,"children":44},"ol",{},[45],{"type":17,"tag":46,"props":47,"children":48},"li",{},[49],{"type":22,"value":50},"创建 PreparedStatement 对象时，需要设置 ResultSet 类型为 TYPE_FORWARD_ONLY，设置 ResultSet 并发模式为 CONCUR_READ_ONLY：",{"type":17,"tag":52,"props":53,"children":58},"pre",{"className":54,"code":56,"language":57,"meta":7},[55],"language-java","PreparedStatement pstmt = conn.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);\n\n","java",[59],{"type":17,"tag":60,"props":61,"children":62},"code",{"__ignoreMap":7},[63],{"type":22,"value":56},{"type":17,"tag":42,"props":65,"children":67},{"start":66},2,[68],{"type":17,"tag":46,"props":69,"children":70},{},[71],{"type":22,"value":72},"通过 setFetchSize() 方法设置每次从数据库中获取的记录数：",{"type":17,"tag":52,"props":74,"children":77},{"className":75,"code":76,"language":57,"meta":7},[55],"pstmt.setFetchSize(fetchSize);\n\n",[78],{"type":17,"tag":60,"props":79,"children":80},{"__ignoreMap":7},[81],{"type":22,"value":76},{"type":17,"tag":42,"props":83,"children":85},{"start":84},3,[86],{"type":17,"tag":46,"props":87,"children":88},{},[89],{"type":22,"value":90},"执行查询语句后，通过 ResultSet 对象的 next() 方法逐条获取查询结果：",{"type":17,"tag":52,"props":92,"children":95},{"className":93,"code":94,"language":57,"meta":7},[55],"ResultSet rs = pstmt.executeQuery();\nwhile (rs.next()) {\n    // 处理查询结果\n}\n\n",[96],{"type":17,"tag":60,"props":97,"children":98},{"__ignoreMap":7},[99],{"type":22,"value":94},{"type":17,"tag":30,"props":101,"children":102},{},[103],{"type":22,"value":104},"需要注意的是，在使用流式查询模式时，ResultSet 对象的一些方法可能会失效，比如 absolute()、last()、previous()、beforeFirst() 等方法。此外，流式查询模式只适用于查询，不适用于更新、插入、删除等操作。",{"type":17,"tag":18,"props":106,"children":108},{"id":107},"三mybatis使用流式查询模式",[109],{"type":22,"value":110},"三、mybatis使用流式查询模式",{"type":17,"tag":42,"props":112,"children":113},{},[114],{"type":17,"tag":46,"props":115,"children":116},{},[117],{"type":22,"value":118},"在 MyBatis 中，可以通过设置 fetchSize 属性来启用流式查询模式，示例如下：",{"type":17,"tag":52,"props":120,"children":123},{"className":121,"code":122,"language":57,"meta":7},[55],"\u003Cselect id=\"selectLargeData\" resultType=\"com.example.LargeData\" fetchSize=\"100\">\n    select * from large_data_table\n\u003C/select>\n\n",[124],{"type":17,"tag":60,"props":125,"children":126},{"__ignoreMap":7},[127],{"type":22,"value":122},{"type":17,"tag":42,"props":129,"children":130},{"start":66},[131],{"type":17,"tag":46,"props":132,"children":133},{},[134],{"type":22,"value":135},"在以上示例中，fetchSize 属性设置为 100，表示每次从数据库中获取 100 条记录，从而实现流式查询。在执行查询操作时，需要通过 while 循环逐条处理查询结果，示例如下：",{"type":17,"tag":52,"props":137,"children":140},{"className":138,"code":139,"language":57,"meta":7},[55],"SqlSession sqlSession = sqlSessionFactory.openSession();\ntry {\n    List\u003CLargeData> largeDataList = new ArrayList\u003C>();\n    try (Cursor\u003CLargeData> cursor = sqlSession.selectCursor(\"selectLargeData\")) {\n        while (cursor.hasNext()) {\n            LargeData largeData = cursor.next();\n            largeDataList.add(largeData);\n        }\n    }\n} finally {\n    sqlSession.close();\n}\n\n",[141],{"type":17,"tag":60,"props":142,"children":143},{"__ignoreMap":7},[144],{"type":22,"value":139},{"type":17,"tag":30,"props":146,"children":147},{},[148],{"type":22,"value":149},"以上示例中，使用了 MyBatis 提供的 Cursor 接口，可以通过 hasNext() 和 next() 方法逐条获取查询结果，从而实现流式处理。",{"type":17,"tag":30,"props":151,"children":152},{},[153],{"type":22,"value":154},"需要注意的是，流式查询模式需要考虑数据库连接的资源占用，因此在使用完毕后需要及时关闭数据库连接。此外，在处理大数据量时，也需要考虑内存占用问题，可以使用分页查询等方法来控制数据量大小。",{"type":17,"tag":18,"props":156,"children":158},{"id":157},"四springbootmybatis使用流式查询模式",[159],{"type":22,"value":160},"四、springboot+mybatis使用流式查询模式",{"type":17,"tag":30,"props":162,"children":163},{},[164,166,170],{"type":22,"value":165},"1.配置数据源",{"type":17,"tag":167,"props":168,"children":169},"br",{},[],{"type":22,"value":171},"\n首先需要在 application.properties 文件中配置数据源，示例如下：",{"type":17,"tag":52,"props":173,"children":176},{"className":174,"code":175,"language":57,"meta":7},[55],"spring.datasource.url=jdbc:mysql://localhost:3306/test\nspring.datasource.username=root\nspring.datasource.password=123456\n",[177],{"type":17,"tag":60,"props":178,"children":179},{"__ignoreMap":7},[180],{"type":22,"value":175},{"type":17,"tag":30,"props":182,"children":183},{},[184],{"type":22,"value":185},"这里以 MySQL 数据库为例，使用 com.mysql.cj.jdbc.Driver 作为驱动程序。",{"type":17,"tag":30,"props":187,"children":188},{},[189,191,194],{"type":22,"value":190},"2.配置 MyBatis",{"type":17,"tag":167,"props":192,"children":193},{},[],{"type":22,"value":195},"\n在 application.properties 文件中配置 MyBatis 相关属性，示例如下：",{"type":17,"tag":52,"props":197,"children":200},{"className":198,"code":199,"language":57,"meta":7},[55],"mybatis.mapper-locations=classpath:mapper/*.xml\nmybatis.configuration.map-underscore-to-camel-case=true\nmybatis.configuration.default-fetch-size=100\n",[201],{"type":17,"tag":60,"props":202,"children":203},{"__ignoreMap":7},[204],{"type":22,"value":199},{"type":17,"tag":30,"props":206,"children":207},{},[208],{"type":22,"value":209},"其中，mapper-locations 属性配置了 MyBatis Mapper 的 XML 文件路径，map-underscore-to-camel-case 属性指定了开启驼峰命名规则，default-fetch-size 属性指定了默认的 fetchSize。",{"type":17,"tag":30,"props":211,"children":212},{},[213,215,218],{"type":22,"value":214},"3.创建 Mapper",{"type":17,"tag":167,"props":216,"children":217},{},[],{"type":22,"value":219},"\n创建 MyBatis Mapper 接口，并在 XML 文件中配置查询语句，示例如下：",{"type":17,"tag":52,"props":221,"children":224},{"className":222,"code":223,"language":57,"meta":7},[55],"public interface LargeDataMapper {\n    @Select(\"select * from large_data_table\")\n    @ResultType(LargeData.class)\n    Cursor\u003CLargeData> selectLargeData();\n}\n",[225],{"type":17,"tag":60,"props":226,"children":227},{"__ignoreMap":7},[228],{"type":22,"value":223},{"type":17,"tag":30,"props":230,"children":231},{},[232],{"type":22,"value":233},"在以上示例中，使用了 MyBatis 提供的 @Select 和 @ResultType 注解，指定了查询语句和返回类型。此外，还使用了 Cursor 接口来实现流式查询。",{"type":17,"tag":30,"props":235,"children":236},{},[237,239,242],{"type":22,"value":238},"4.查询数据",{"type":17,"tag":167,"props":240,"children":241},{},[],{"type":22,"value":243},"\n在 Service 层中调用 Mapper 方法，并使用 while 循环逐条处理查询结果，示例如下：",{"type":17,"tag":52,"props":245,"children":248},{"className":246,"code":247,"language":57,"meta":7},[55],"@Service\npublic class LargeDataService {\n    @Autowired\n    private LargeDataMapper largeDataMapper;\n  \n    public List\u003CLargeData> selectLargeData() {\n        try (Cursor\u003CLargeData> cursor = largeDataMapper.selectLargeData()) {\n            List\u003CLargeData> largeDataList = new ArrayList\u003C>();\n            while (cursor.hasNext()) {\n                LargeData largeData = cursor.next();\n                largeDataList.add(largeData);\n            }\n            return largeDataList;\n        }\n    }\n}\n",[249],{"type":17,"tag":60,"props":250,"children":251},{"__ignoreMap":7},[252],{"type":22,"value":247},{"type":17,"tag":30,"props":254,"children":255},{},[256],{"type":22,"value":257},"在以上示例中，使用了 try-with-resources 语句来确保资源及时关闭。同时，在 while 循环中逐条处理查询结果，并将结果添加到 List 中返回。",{"type":17,"tag":30,"props":259,"children":260},{},[261],{"type":22,"value":262},"总的来说，使用 Spring Boot 和 MyBatis 实现流式查询模式比较简单，只需要在配置文件中设置 fetchSize 属性和默认的 fetchSize，然后在 Mapper 接口中使用 Cursor 接口实现流式查询，即可避免内存溢出和提高查询速度。",{"type":17,"tag":18,"props":264,"children":266},{"id":265},"五springboot-jpa流式查询模式",[267],{"type":22,"value":268},"五、springboot jpa流式查询模式",{"type":17,"tag":30,"props":270,"children":271},{},[272],{"type":22,"value":273},"首先，我们需要创建一个实体类 User，用于表示用户信息：",{"type":17,"tag":52,"props":275,"children":278},{"className":276,"code":277,"language":57,"meta":7},[55],"@Entity\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String name;\n\n    private Integer age;\n\n    // 省略 getter 和 setter 方法\n}\n",[279],{"type":17,"tag":60,"props":280,"children":281},{"__ignoreMap":7},[282],{"type":22,"value":277},{"type":17,"tag":30,"props":284,"children":285},{},[286],{"type":22,"value":287},"然后，我们需要创建一个 UserRepository 接口，用于定义查询方法：",{"type":17,"tag":52,"props":289,"children":292},{"className":290,"code":291,"language":57,"meta":7},[55],"@Repository\npublic interface UserRepository extends JpaRepository\u003CUser, Long> {\n\n    @Query(\"SELECT u FROM User u\")\n    Stream\u003CUser> findAllByStream();\n\n}\n",[293],{"type":17,"tag":60,"props":294,"children":295},{"__ignoreMap":7},[296],{"type":22,"value":291},{"type":17,"tag":30,"props":298,"children":299},{},[300,302],{"type":22,"value":301},"在上面的代码中，我们使用 @Query 注解定义了一个查询语句，该语句返回一个 Stream",{"type":17,"tag":303,"props":304,"children":305},"user",{},[306],{"type":22,"value":307}," 对象，该对象包含所有用户。",{"type":17,"tag":30,"props":309,"children":310},{},[311],{"type":22,"value":312},"接下来，我们需要编写一个 UserService 类，用于调用 UserRepository 中的方法：",{"type":17,"tag":52,"props":314,"children":317},{"className":315,"code":316,"language":57,"meta":7},[55],"@Service\npublic class UserService {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Transactional(readOnly = true)\n    public void findAllUsersByStream() {\n        try (Stream\u003CUser> stream = userRepository.findAllByStream()) {\n            stream.forEach(user -> {\n                // 处理用户数据\n                System.out.println(user);\n            });\n        }\n    }\n\n}\n",[318],{"type":17,"tag":60,"props":319,"children":320},{"__ignoreMap":7},[321],{"type":22,"value":316},{"type":17,"tag":30,"props":323,"children":324},{},[325],{"type":22,"value":326},"在上面的代码中，我们注入了 UserRepository 对象，并且定义了一个 findAllUsersByStream 方法，该方法使用 @Transactional 注解将方法声明为只读事务。",{"type":17,"tag":30,"props":328,"children":329},{},[330,332],{"type":22,"value":331},"在方法中，我们使用 try-with-resources 语句来获取一个 Stream",{"type":17,"tag":303,"props":333,"children":334},{},[335],{"type":22,"value":336}," 对象，并使用 forEach 方法遍历所有用户数据。由于使用了 try-with-resources 语句，所以当处理完用户数据后，stream 对象会自动关闭。",{"type":17,"tag":30,"props":338,"children":339},{},[340],{"type":22,"value":341},"最后，我们可以在应用程序的入口类中调用 UserService 中的方法：",{"type":17,"tag":52,"props":343,"children":346},{"className":344,"code":345,"language":57,"meta":7},[55],"@SpringBootApplication\npublic class Application implements CommandLineRunner {\n\n    @Autowired\n    private UserService userService;\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n        userService.findAllUsersByStream();\n    }\n\n}\n",[347],{"type":17,"tag":60,"props":348,"children":349},{"__ignoreMap":7},[350],{"type":22,"value":345},{"type":17,"tag":30,"props":352,"children":353},{},[354],{"type":22,"value":355},"在上面的代码中，我们注入了 UserService 对象，并在 run 方法中调用了 findAllUsersByStream 方法。",{"type":17,"tag":18,"props":357,"children":359},{"id":358},"注流式查询模式速度会不会比较慢查询到的信息",[360],{"type":22,"value":361},"注：流式查询模式速度会不会比较慢(查询到的信息)",{"type":17,"tag":30,"props":363,"children":364},{},[365],{"type":22,"value":366},"流式查询模式并不一定比非流式查询模式慢，其查询速度主要取决于数据访问方式和网络传输速度等因素。",{"type":17,"tag":30,"props":368,"children":369},{},[370],{"type":22,"value":371},"流式查询模式的优点是可以避免将大量数据一次性加载到内存中，降低了内存占用，尤其是在处理大数据量时可以明显提高程序性能。此外，流式查询模式还可以更快地获取第一条数据，因为数据是逐条传输的。",{"type":17,"tag":30,"props":373,"children":374},{},[375],{"type":22,"value":376},"但是，流式查询模式的缺点是每次从数据库获取数据的时间较长，因为数据是逐条传输的。此外，流式查询模式可能会增加数据库服务器的负载，因为服务器需要不断发送数据到客户端。",{"type":17,"tag":30,"props":378,"children":379},{},[380],{"type":22,"value":381},"综上所述，流式查询模式的使用要根据具体情况来决定，需要考虑数据量大小、网络传输速度、查询方式等因素。对于大数据量的查询操作，流式查询模式往往是更优的选择，可以显著提高程序性能。",{"title":7,"searchDepth":66,"depth":66,"links":383},[],"markdown","content:dir:java流模式查询.md","content","dir/java流模式查询.md","dir/java流模式查询","md",{"loc":4},1732067473001]