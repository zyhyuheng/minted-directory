[{"data":1,"prerenderedAt":414},["ShallowReactive",2],{"tag-SAAS":3},[4,392],{"_path":5,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":9,"description":8,"cover":10,"featured":11,"tags":12,"body":14,"_type":385,"_id":386,"_source":387,"_file":388,"_stem":389,"_extension":390,"sitemap":391},"/dir/java","dir",false,"","java流模式查询","/logo.png",true,[13],"SAAS",{"type":15,"children":16,"toc":383},"root",[17,24,30,36,42,52,65,74,83,92,101,106,112,120,129,137,146,151,156,162,173,182,187,197,206,211,221,230,235,245,254,259,264,270,275,284,289,298,309,314,323,328,338,343,352,357,363,368,373,378],{"type":18,"tag":19,"props":20,"children":21},"element","h1",{"id":9},[22],{"type":23,"value":9},"text",{"type":18,"tag":19,"props":25,"children":27},{"id":26},"一流式查询模式简介",[28],{"type":23,"value":29},"一、流式查询模式简介",{"type":18,"tag":31,"props":32,"children":33},"p",{},[34],{"type":23,"value":35},"流式查询模式是一种优化查询的方法，可以在查询大量数据时降低内存占用，提高查询速度。在流式查询模式下，查询结果是逐条从数据库服务器流式传输到客户端，而不是一次性将所有查询结果加载到内存中。",{"type":18,"tag":19,"props":37,"children":39},{"id":38},"二jdbc流式查询模式",[40],{"type":23,"value":41},"二、JDBC流式查询模式",{"type":18,"tag":43,"props":44,"children":45},"ol",{},[46],{"type":18,"tag":47,"props":48,"children":49},"li",{},[50],{"type":23,"value":51},"创建 PreparedStatement 对象时，需要设置 ResultSet 类型为 TYPE_FORWARD_ONLY，设置 ResultSet 并发模式为 CONCUR_READ_ONLY：",{"type":18,"tag":53,"props":54,"children":59},"pre",{"className":55,"code":57,"language":58,"meta":8},[56],"language-java","PreparedStatement pstmt = conn.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);\n\n","java",[60],{"type":18,"tag":61,"props":62,"children":63},"code",{"__ignoreMap":8},[64],{"type":23,"value":57},{"type":18,"tag":43,"props":66,"children":68},{"start":67},2,[69],{"type":18,"tag":47,"props":70,"children":71},{},[72],{"type":23,"value":73},"通过 setFetchSize() 方法设置每次从数据库中获取的记录数：",{"type":18,"tag":53,"props":75,"children":78},{"className":76,"code":77,"language":58,"meta":8},[56],"pstmt.setFetchSize(fetchSize);\n\n",[79],{"type":18,"tag":61,"props":80,"children":81},{"__ignoreMap":8},[82],{"type":23,"value":77},{"type":18,"tag":43,"props":84,"children":86},{"start":85},3,[87],{"type":18,"tag":47,"props":88,"children":89},{},[90],{"type":23,"value":91},"执行查询语句后，通过 ResultSet 对象的 next() 方法逐条获取查询结果：",{"type":18,"tag":53,"props":93,"children":96},{"className":94,"code":95,"language":58,"meta":8},[56],"ResultSet rs = pstmt.executeQuery();\nwhile (rs.next()) {\n    // 处理查询结果\n}\n\n",[97],{"type":18,"tag":61,"props":98,"children":99},{"__ignoreMap":8},[100],{"type":23,"value":95},{"type":18,"tag":31,"props":102,"children":103},{},[104],{"type":23,"value":105},"需要注意的是，在使用流式查询模式时，ResultSet 对象的一些方法可能会失效，比如 absolute()、last()、previous()、beforeFirst() 等方法。此外，流式查询模式只适用于查询，不适用于更新、插入、删除等操作。",{"type":18,"tag":19,"props":107,"children":109},{"id":108},"三mybatis使用流式查询模式",[110],{"type":23,"value":111},"三、mybatis使用流式查询模式",{"type":18,"tag":43,"props":113,"children":114},{},[115],{"type":18,"tag":47,"props":116,"children":117},{},[118],{"type":23,"value":119},"在 MyBatis 中，可以通过设置 fetchSize 属性来启用流式查询模式，示例如下：",{"type":18,"tag":53,"props":121,"children":124},{"className":122,"code":123,"language":58,"meta":8},[56],"\u003Cselect id=\"selectLargeData\" resultType=\"com.example.LargeData\" fetchSize=\"100\">\n    select * from large_data_table\n\u003C/select>\n\n",[125],{"type":18,"tag":61,"props":126,"children":127},{"__ignoreMap":8},[128],{"type":23,"value":123},{"type":18,"tag":43,"props":130,"children":131},{"start":67},[132],{"type":18,"tag":47,"props":133,"children":134},{},[135],{"type":23,"value":136},"在以上示例中，fetchSize 属性设置为 100，表示每次从数据库中获取 100 条记录，从而实现流式查询。在执行查询操作时，需要通过 while 循环逐条处理查询结果，示例如下：",{"type":18,"tag":53,"props":138,"children":141},{"className":139,"code":140,"language":58,"meta":8},[56],"SqlSession sqlSession = sqlSessionFactory.openSession();\ntry {\n    List\u003CLargeData> largeDataList = new ArrayList\u003C>();\n    try (Cursor\u003CLargeData> cursor = sqlSession.selectCursor(\"selectLargeData\")) {\n        while (cursor.hasNext()) {\n            LargeData largeData = cursor.next();\n            largeDataList.add(largeData);\n        }\n    }\n} finally {\n    sqlSession.close();\n}\n\n",[142],{"type":18,"tag":61,"props":143,"children":144},{"__ignoreMap":8},[145],{"type":23,"value":140},{"type":18,"tag":31,"props":147,"children":148},{},[149],{"type":23,"value":150},"以上示例中，使用了 MyBatis 提供的 Cursor 接口，可以通过 hasNext() 和 next() 方法逐条获取查询结果，从而实现流式处理。",{"type":18,"tag":31,"props":152,"children":153},{},[154],{"type":23,"value":155},"需要注意的是，流式查询模式需要考虑数据库连接的资源占用，因此在使用完毕后需要及时关闭数据库连接。此外，在处理大数据量时，也需要考虑内存占用问题，可以使用分页查询等方法来控制数据量大小。",{"type":18,"tag":19,"props":157,"children":159},{"id":158},"四springbootmybatis使用流式查询模式",[160],{"type":23,"value":161},"四、springboot+mybatis使用流式查询模式",{"type":18,"tag":31,"props":163,"children":164},{},[165,167,171],{"type":23,"value":166},"1.配置数据源",{"type":18,"tag":168,"props":169,"children":170},"br",{},[],{"type":23,"value":172},"\n首先需要在 application.properties 文件中配置数据源，示例如下：",{"type":18,"tag":53,"props":174,"children":177},{"className":175,"code":176,"language":58,"meta":8},[56],"spring.datasource.url=jdbc:mysql://localhost:3306/test\nspring.datasource.username=root\nspring.datasource.password=123456\n",[178],{"type":18,"tag":61,"props":179,"children":180},{"__ignoreMap":8},[181],{"type":23,"value":176},{"type":18,"tag":31,"props":183,"children":184},{},[185],{"type":23,"value":186},"这里以 MySQL 数据库为例，使用 com.mysql.cj.jdbc.Driver 作为驱动程序。",{"type":18,"tag":31,"props":188,"children":189},{},[190,192,195],{"type":23,"value":191},"2.配置 MyBatis",{"type":18,"tag":168,"props":193,"children":194},{},[],{"type":23,"value":196},"\n在 application.properties 文件中配置 MyBatis 相关属性，示例如下：",{"type":18,"tag":53,"props":198,"children":201},{"className":199,"code":200,"language":58,"meta":8},[56],"mybatis.mapper-locations=classpath:mapper/*.xml\nmybatis.configuration.map-underscore-to-camel-case=true\nmybatis.configuration.default-fetch-size=100\n",[202],{"type":18,"tag":61,"props":203,"children":204},{"__ignoreMap":8},[205],{"type":23,"value":200},{"type":18,"tag":31,"props":207,"children":208},{},[209],{"type":23,"value":210},"其中，mapper-locations 属性配置了 MyBatis Mapper 的 XML 文件路径，map-underscore-to-camel-case 属性指定了开启驼峰命名规则，default-fetch-size 属性指定了默认的 fetchSize。",{"type":18,"tag":31,"props":212,"children":213},{},[214,216,219],{"type":23,"value":215},"3.创建 Mapper",{"type":18,"tag":168,"props":217,"children":218},{},[],{"type":23,"value":220},"\n创建 MyBatis Mapper 接口，并在 XML 文件中配置查询语句，示例如下：",{"type":18,"tag":53,"props":222,"children":225},{"className":223,"code":224,"language":58,"meta":8},[56],"public interface LargeDataMapper {\n    @Select(\"select * from large_data_table\")\n    @ResultType(LargeData.class)\n    Cursor\u003CLargeData> selectLargeData();\n}\n",[226],{"type":18,"tag":61,"props":227,"children":228},{"__ignoreMap":8},[229],{"type":23,"value":224},{"type":18,"tag":31,"props":231,"children":232},{},[233],{"type":23,"value":234},"在以上示例中，使用了 MyBatis 提供的 @Select 和 @ResultType 注解，指定了查询语句和返回类型。此外，还使用了 Cursor 接口来实现流式查询。",{"type":18,"tag":31,"props":236,"children":237},{},[238,240,243],{"type":23,"value":239},"4.查询数据",{"type":18,"tag":168,"props":241,"children":242},{},[],{"type":23,"value":244},"\n在 Service 层中调用 Mapper 方法，并使用 while 循环逐条处理查询结果，示例如下：",{"type":18,"tag":53,"props":246,"children":249},{"className":247,"code":248,"language":58,"meta":8},[56],"@Service\npublic class LargeDataService {\n    @Autowired\n    private LargeDataMapper largeDataMapper;\n  \n    public List\u003CLargeData> selectLargeData() {\n        try (Cursor\u003CLargeData> cursor = largeDataMapper.selectLargeData()) {\n            List\u003CLargeData> largeDataList = new ArrayList\u003C>();\n            while (cursor.hasNext()) {\n                LargeData largeData = cursor.next();\n                largeDataList.add(largeData);\n            }\n            return largeDataList;\n        }\n    }\n}\n",[250],{"type":18,"tag":61,"props":251,"children":252},{"__ignoreMap":8},[253],{"type":23,"value":248},{"type":18,"tag":31,"props":255,"children":256},{},[257],{"type":23,"value":258},"在以上示例中，使用了 try-with-resources 语句来确保资源及时关闭。同时，在 while 循环中逐条处理查询结果，并将结果添加到 List 中返回。",{"type":18,"tag":31,"props":260,"children":261},{},[262],{"type":23,"value":263},"总的来说，使用 Spring Boot 和 MyBatis 实现流式查询模式比较简单，只需要在配置文件中设置 fetchSize 属性和默认的 fetchSize，然后在 Mapper 接口中使用 Cursor 接口实现流式查询，即可避免内存溢出和提高查询速度。",{"type":18,"tag":19,"props":265,"children":267},{"id":266},"五springboot-jpa流式查询模式",[268],{"type":23,"value":269},"五、springboot jpa流式查询模式",{"type":18,"tag":31,"props":271,"children":272},{},[273],{"type":23,"value":274},"首先，我们需要创建一个实体类 User，用于表示用户信息：",{"type":18,"tag":53,"props":276,"children":279},{"className":277,"code":278,"language":58,"meta":8},[56],"@Entity\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String name;\n\n    private Integer age;\n\n    // 省略 getter 和 setter 方法\n}\n",[280],{"type":18,"tag":61,"props":281,"children":282},{"__ignoreMap":8},[283],{"type":23,"value":278},{"type":18,"tag":31,"props":285,"children":286},{},[287],{"type":23,"value":288},"然后，我们需要创建一个 UserRepository 接口，用于定义查询方法：",{"type":18,"tag":53,"props":290,"children":293},{"className":291,"code":292,"language":58,"meta":8},[56],"@Repository\npublic interface UserRepository extends JpaRepository\u003CUser, Long> {\n\n    @Query(\"SELECT u FROM User u\")\n    Stream\u003CUser> findAllByStream();\n\n}\n",[294],{"type":18,"tag":61,"props":295,"children":296},{"__ignoreMap":8},[297],{"type":23,"value":292},{"type":18,"tag":31,"props":299,"children":300},{},[301,303],{"type":23,"value":302},"在上面的代码中，我们使用 @Query 注解定义了一个查询语句，该语句返回一个 Stream",{"type":18,"tag":304,"props":305,"children":306},"user",{},[307],{"type":23,"value":308}," 对象，该对象包含所有用户。",{"type":18,"tag":31,"props":310,"children":311},{},[312],{"type":23,"value":313},"接下来，我们需要编写一个 UserService 类，用于调用 UserRepository 中的方法：",{"type":18,"tag":53,"props":315,"children":318},{"className":316,"code":317,"language":58,"meta":8},[56],"@Service\npublic class UserService {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Transactional(readOnly = true)\n    public void findAllUsersByStream() {\n        try (Stream\u003CUser> stream = userRepository.findAllByStream()) {\n            stream.forEach(user -> {\n                // 处理用户数据\n                System.out.println(user);\n            });\n        }\n    }\n\n}\n",[319],{"type":18,"tag":61,"props":320,"children":321},{"__ignoreMap":8},[322],{"type":23,"value":317},{"type":18,"tag":31,"props":324,"children":325},{},[326],{"type":23,"value":327},"在上面的代码中，我们注入了 UserRepository 对象，并且定义了一个 findAllUsersByStream 方法，该方法使用 @Transactional 注解将方法声明为只读事务。",{"type":18,"tag":31,"props":329,"children":330},{},[331,333],{"type":23,"value":332},"在方法中，我们使用 try-with-resources 语句来获取一个 Stream",{"type":18,"tag":304,"props":334,"children":335},{},[336],{"type":23,"value":337}," 对象，并使用 forEach 方法遍历所有用户数据。由于使用了 try-with-resources 语句，所以当处理完用户数据后，stream 对象会自动关闭。",{"type":18,"tag":31,"props":339,"children":340},{},[341],{"type":23,"value":342},"最后，我们可以在应用程序的入口类中调用 UserService 中的方法：",{"type":18,"tag":53,"props":344,"children":347},{"className":345,"code":346,"language":58,"meta":8},[56],"@SpringBootApplication\npublic class Application implements CommandLineRunner {\n\n    @Autowired\n    private UserService userService;\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n        userService.findAllUsersByStream();\n    }\n\n}\n",[348],{"type":18,"tag":61,"props":349,"children":350},{"__ignoreMap":8},[351],{"type":23,"value":346},{"type":18,"tag":31,"props":353,"children":354},{},[355],{"type":23,"value":356},"在上面的代码中，我们注入了 UserService 对象，并在 run 方法中调用了 findAllUsersByStream 方法。",{"type":18,"tag":19,"props":358,"children":360},{"id":359},"注流式查询模式速度会不会比较慢查询到的信息",[361],{"type":23,"value":362},"注：流式查询模式速度会不会比较慢(查询到的信息)",{"type":18,"tag":31,"props":364,"children":365},{},[366],{"type":23,"value":367},"流式查询模式并不一定比非流式查询模式慢，其查询速度主要取决于数据访问方式和网络传输速度等因素。",{"type":18,"tag":31,"props":369,"children":370},{},[371],{"type":23,"value":372},"流式查询模式的优点是可以避免将大量数据一次性加载到内存中，降低了内存占用，尤其是在处理大数据量时可以明显提高程序性能。此外，流式查询模式还可以更快地获取第一条数据，因为数据是逐条传输的。",{"type":18,"tag":31,"props":374,"children":375},{},[376],{"type":23,"value":377},"但是，流式查询模式的缺点是每次从数据库获取数据的时间较长，因为数据是逐条传输的。此外，流式查询模式可能会增加数据库服务器的负载，因为服务器需要不断发送数据到客户端。",{"type":18,"tag":31,"props":379,"children":380},{},[381],{"type":23,"value":382},"综上所述，流式查询模式的使用要根据具体情况来决定，需要考虑数据量大小、网络传输速度、查询方式等因素。对于大数据量的查询操作，流式查询模式往往是更优的选择，可以显著提高程序性能。",{"title":8,"searchDepth":67,"depth":67,"links":384},[],"markdown","content:dir:java流模式查询.md","content","dir/java流模式查询.md","dir/java流模式查询","md",{"loc":5},{"_path":393,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":394,"description":395,"cover":10,"featured":11,"tags":396,"body":397,"_type":385,"_id":410,"_source":387,"_file":411,"_stem":412,"_extension":390,"sitemap":413},"/dir/starter","First Listing","This is an example listing to get started.",[13],{"type":15,"children":398,"toc":408},[399,404],{"type":18,"tag":19,"props":400,"children":402},{"id":401},"first-listing",[403],{"type":23,"value":394},{"type":18,"tag":31,"props":405,"children":406},{},[407],{"type":23,"value":395},{"title":8,"searchDepth":67,"depth":67,"links":409},[],"content:dir:starter.md","dir/starter.md","dir/starter",{"loc":393},1732067473121]